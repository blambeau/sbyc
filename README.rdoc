= SByC - Code Tree and Type System (git branch)

This is a particular branch of the SByC library which aims at investigating a type system relying on Specialization By Constraints. This branch implements a small functional engine (parser + ast rewriting + type checker).

ATTENTION!!! This ruby library is under active development. Some of the examples may not work so far ;-)

== Friendly block DSLs

SByC provides a safe, reusable, extensible, and non-intrusive (no monkey patching of Ruby core classes) implementation of block DSLs. The following styles are recognized:

  # Hash-style
  SByC::parse{|t| (t[:x] > 5) & (t[:y] <= 10) }     # => (& (> (? :x), 5), (<= (? :y), 10))
  
  # Object-style
  SByC::parse{|t| (t.x > 5) & (t.y <= 10)     }     # => (& (> (? :x), 5), (<= (? :z), 10))
  
  # Context-style
  SByC::parse{ (x > 5) & (y <= 10)            }     # => (& (> (? :x), 5), (<= (? :z), 10))

  # Functional-style
  SByC::parse{ (both (gt x, 5), (lte y, 10))  }     # => (both (gt (? :x), 5), (lte (? :z), 10))

The parsing stage returns a functional Abstract Syntax Tree, which can be passed to a next stage (rewriting, evaluation, compilation or whatever). Shortcuts for common next-stages are already proposed:

  #
  # Re-evaluate the AST with an object semantics in mind: 
  #   the method/operator is sent on its first argument
  #
  expr = SByC::parse{ x + y }                       # => (+ x, y)
  expr.object_eval(:x => 12, :y => 28)              # => 40 (executed as '12.+(18)')

  #
  # Re-evaluate the AST with an functional semantics in mind: 
  #   the method/operator is sent on a global object
  #
  expr = SByC::parse{ (puts x, y) }                 # => (puts x, " ", y)
  expr.functional_eval(Kernel, :x => 12, :y => 28)  # => 12\n28 (executed as Kernel.puts(12, 28))

== Assumptions & Limitations (examples that DO NOT work)

* SByC implicitly assumes that block's code can be interpreted functionally: no concept of variable, no sequence of code, no if/then/else, no loop. Said otherwise: your block code should always "compute a value", without any other (state) side effect. The following will NOT work:

    SByC::parse{ if x then 0 else 1 end }           # 0

* SByC does not uses ruby2ruby or similar libraries to get an AST. It simply executes the block inside a specific DSL. Therefore, ruby expressions on literals will be evaluated at parsing time, according to operator precedence and ordering:
  
    SByC::parse{ x + 12 + 17     }                  # => (+ (+ (? :x), 12), 17)
    SByC::parse{ x + (12 + 17)   }                  # => (+ (? :x), 29)
    SByC::parse{ (x + 12) + 17   }                  # => (+ (+ (? :x), 12), 17)

* For the same reason, only operators that rely on overridable methods are recognized. In particular, the following expressions will NOT work:

    SByC::parse{ x and y }                          # => (? :y)
    SByC::parse{ x && y  }                          # => (? :y)
    SByC::parse{ x or y  }                          # => (? :x)
    SByC::parse{ x || y  }                          # => (? :x)
    SByC::parse{ not(x)  }                          # => false          # Works using Ruby >= 1.9.1
    SByC::parse{ !x      }                          # => false          # Works using Ruby >= 1.9.1

== Example of later stages, the Rewriter engine!

Consider the following (functional) example. 

  ast = SByC::parse{ (concat "hello ", (get :who), (times "!", 3)) }

=== An evaluation stage

  # Evaluate the code above:
  rewriter = ::SByC::Rewriter.new {|r|
    r.rule(:concat)    {|r, node, *children|   children.collect{|c| r.apply(c)}.join("") }  
    r.rule(:capitalize){|r, node, who|         r.apply(who).capitalize                   }
    r.rule(:times)     {|r, node, who, times|  r.apply(who) * r.apply(times)             }
    r.rule(:get)       {|r, node, what|        scope[r.apply(what)]                      }
    r.rule(:_)         {|r, node|              node.literal                              }
  }
  puts rewriter.rewrite(ast, :who => "SByC")      # => "hello SByC!!!"

=== A compilation stage  

  # Generate ruby code for the code above:
  rewriter = ::SByC::Rewriter.new {|r|
    r.rule(:concat)    {|r, node, *children|   children.collect{|c| r.apply(c)}.join(" + ") }  
    r.rule(:capitalize){|r, node, who|         "#{r.apply(who)}.capitalize()"               }
    r.rule(:times)     {|r, node, who, times|  "(#{r.apply(who)} * #{r.apply(times)})"      }
    r.rule(:get)       {|r, node, what|        "scope[#{r.apply(what)}]"                    }
    r.rule(:_)         {|r, node|              node.literal.inspect                         }
  }
  puts rewriter.rewrite(ast)                     # "hello " + scope[:who] + ("!" * 3)
