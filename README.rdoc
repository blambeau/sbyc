= SByC - Code Tree and Type System (git branch)

This is a particular branch of the SByC library which aims at investigating a type system relying on Specialization By Constraints. This branch implements a small functional engine (parser + ast rewriting + type checker).

ATTENTION!!! This ruby library is under active development. Some of the examples may not work so far ;-)

== Generic virtual blocks

Many ruby gems implement specific DSLs to create predicates and/or logic expressions inside lambda functions. For instance, 

  # Extracted from Sequel documentation
  DB[:items].filter{|o| (o.x > 5) & (o.y <= 10)}.sql   # => "SELECT * FROM items WHERE ((x > 5) AND (y > 10))"

  # Other examples in Sequel
  dataset.filter{a & (b | ~c)}
  dataset.select{a + b}

SByC provides a reusable and extensible implementation of such DSL hacks... because it cleanly separates parsing from compilation mechanisms!

  # Parsing stage
  code     = lambda{|t| (t[:x] > 5) & (t[:y] <= 10)}
  ast      = SByC::parse_imperative(code)       # => (bool_and (gt (get :x), 5), (lte (get :y), 10))

  # Compilation stage
  compiled = SByC::RubySystem::compile(code)    # => <Proc:...@...>
  result   = compiled.call(:x => 7, :y => 15)   # => false
  
  # And the RubySystem has a type checker ;-)
  puts compiled.type_check(:x => 7, :y => 15)   # => Integer

The story does not stop here... You can of course provide your own compilation mechanisms!

== Functional engine and rewriting

The ability to parse imperative blocks is a small visible feature of SByC. More generally, SByC is based on a functional engine that parses LISP inspired functional expressions:

  code = lambda{ (concat "hello ", (get :who), (times "!", 3)) }
  ast  = ::SByC::parse(code)                    # => (concat ...)

Parse trees may be analyzed by user-defined systems. Creating such a system for your own needs starts with understanding the rewriter engine:

  # Evaluate the code above:
  rewriter = ::SByC::Rewriter.new {|r|
    r.rule(:concat)    {|r, node, *children|   children.collect{|c| r.apply(c)}.join("") }  
    r.rule(:capitalize){|r, node, who|         r.apply(who).capitalize                   }
    r.rule(:times)     {|r, node, who, times|  r.apply(who) * r.apply(times)             }
    r.rule(:get)       {|r, node, what|        scope[r.apply(what)]                      }
    r.rule(:literal)   {|r, node|              node.literal                              }
  }
  puts rewriter.rewrite(ast, :who => "SByC")      # => "hello SByC!!!"
  
  # Generate ruby code for the code above:
  rewriter = ::SByC::Rewriter.new {|r|
    r.rule(:concat)    {|r, node, *children|   children.collect{|c| r.apply(c)}.join(" + ") }  
    r.rule(:capitalize){|r, node, who|         "#{r.apply(who)}.capitalize()"               }
    r.rule(:times)     {|r, node, who, times|  "(#{r.apply(who)} * #{r.apply(times)})"      }
    r.rule(:get)       {|r, node, what|        "scope[#{r.apply(what)}]"                    }
    r.rule(:literal)   {|r, node|              node.literal.inspect                         }
  }
  puts rewriter.rewrite(ast)                     # "hello " + scope[:who] + ("!" * 3)

== Roadmap

To appear.
