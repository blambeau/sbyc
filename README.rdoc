= SByC - Code Tree and Type System (git branch)

This is a particular branch of the SByC library which aims at investigating a type system relying on Specialization By Constraints. This branch implements a small functional engine (parser + ast rewriting + type checker).

ATTENTION!!! This ruby library is under active development. Some of the examples may not work so far ;-)

== Generic virtual blocks

Many ruby gems implement specific DSLs to create predicates and/or logic expressions inside lambda functions. For instance, 

  # Extracted from Sequel documentation
  DB[:items].filter{|o| (o.x > 5) & (o.y <= 10)}.sql   # => "SELECT * FROM items WHERE ((x > 5) AND (y > 10))"

  # Other examples in Sequel
  dataset.filter{a & (b | ~c)}
  dataset.select{a + b}

SByC provides a reusable and extensible implementation of such DSL hacks... because it cleanly separates parsing from compilation mechanisms!

  # Parsing stage
  code     = lambda{|t| (t[:x] > 5) & (t[:y] <= 10)}
  ast      = SByC::parse_imperative(code)       # => (bool_and (gt (get :x), 5), (lte (get :y), 10))

  # Compilation stage
  compiled = SByC::RubySystem::compile(code)    # => <Proc:...@...>
  result   = compiled.call(:x => 7, :y => 15)   # => false
  
  # And the RubySystem has a type checker ;-)
  puts compiled.type_check(:x => 7, :y => 15)   # => Integer

The story does not stop here... You can of course provide your own compilation mechanisms!

== Functional engine and rewriting

The ability to parse imperative blocks is a small visible feature of SByC. More generally, SByC is based on a functional engine that parses LISP inspired functional expressions:

  code = lambda{ (concat "hello world", " ", (times "!", 3)) }

Parse trees may be analyzed by user-defined systems. A default ruby system is provided for typical tasks:

  SByC::RubySystem.type_check(code)              # => String
  SByC::RubySystem.execute(code)                 # => "hello world !!!"

Creating such a system for your own needs starts with understanding the rewriter engine:

  # Evaluate the code above:
  rewriter = ::SByC::Rewriter.new {|r|
    r.rule(:concat)    {|r, *args| args.collect{|c| r.apply(c)}.join("") }  
    r.rule(:capitalize){|r, w|     r.apply(w).capitalize                 }
    r.rule(:times)     {|r, w, n|  r.apply(w) * r.apply(n)               }
    r.rule(:literal)   {|r, l|     l.literal                             }
  }
  puts rewriter.rewrite(ast)                     # => "hello world !!!"
  
  # Generate ruby code for the code above:
  rewriter = ::SByC::Rewriter.new {|r|
    r.rule(:concat)    {|r, *args| args.collect{|c| r.apply(c)}.join(" + ") }  
    r.rule(:capitalize){|r, w|     "#{r.apply(w)}.capitalize()"             }
    r.rule(:times)     {|r,w,n|    "(#{r.apply(w)} * #{r.apply(n)})"        }
    r.rule(:literal)   {|r,l|      l.literal.inspect                        }
  }
  puts rewriter.rewrite(ast)                     # "hello world" + " " + ("!" * 3)

== Roadmap

To appear.
