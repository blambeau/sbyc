<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" >
<html>
	<head> 
		<title>SByC - Investigating Specialization by Constraint</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<base href="http://blambeau.github.com/sbyc/"/>
		<link rel="stylesheet" type="text/css" href="css/style.css" />
		<link rel="stylesheet" type="text/css" href="css/menu.css" />
		<link rel="stylesheet" type="text/css" href="css/coderay.css" />
	</head>
	<body>
	  <div id="header">
	    <div class="left">
	      This feature is part of <a href="index.html">SByC</a>
	    </div>
	    <div class="right">
  	    <span>SByC on</span>
  	    <a href="http://rdoc.info/projects/blambeau/sbyc">rdoc.info</a>
  	    <a href="http://github.com/blambeau/sbyc">GitHub</a>
  	  </div>
	  </div>
	  <div id="main">
      <h1>CodeTree - Reusable block expressions</h1>
      <div id="menu_wrapper" class="black">
        <ul id="menu">
          <li class="active"><a href="codetree.html">Home</a></li>
          <li ><a href="codetree/production.html">Production</a></li>
          <li ><a href="codetree/evaluation.html">Evaluation</a></li>
          <li ><a href="codetree/codegen.html">Code generation</a></li>

        </ul>
      </div>
      <div class="text">
<h2>synopsis</h2>
<p>This part of SByC provides a safe, reusable, extensible, mashallable, and non-intrusive (no monkey patching of Ruby core classes) implementation of block expressions. Block expressions are parsed using a generic <span class="caps">DSL</span> and converted to a parse tree, which may be analyzed, rewrited, compiled, and so on. The following example illustrates typical usage of CodeTree::parse.</p>
<div class="CodeRay">
  <div class="code"><pre>code = <span class="co">CodeTree</span>::parse{ x &gt; <span class="i">10</span> &amp; y &lt; <span class="i">20</span> }   
<span class="c"># =&gt; (&amp; (&gt; x, 10), (&lt; y, 20))</span>

<span class="c"># See the evaluation section for details</span>
code.eval{<span class="sy">:x</span> =&gt; <span class="i">5</span>, <span class="sy">:y</span> =&gt; <span class="i">5</span>}                
<span class="c"># =&gt; true</span>

<span class="c"># See the code-generation section for details</span>
code.object_compile(<span class="s"><span class="dl">'</span><span class="k">scope</span><span class="dl">'</span></span>, <span class="sy">:[]</span>)          
<span class="c"># =&gt; &quot;scope[:x].&gt;(10) &amp; scope[:y].&lt;(20)&quot;</span>

<span class="c"># CodeTree expressions may be marshaled</span>
<span class="co">Marshal</span>.dump(code)
</pre></div>
</div>

<h2>syntax</h2>
<p>The following styles are recognized:</p>
<div class="CodeRay">
  <div class="code"><pre><span class="c"># Hash-style</span>
<span class="co">CodeTree</span>::parse{|t| (t[<span class="sy">:x</span>] &gt; <span class="i">5</span>) &amp; (t[<span class="sy">:y</span>] &lt;= <span class="i">10</span>) }  <span class="c"># =&gt; (&amp; (&gt; x, 5), (&lt;= y, 10))</span>

<span class="c"># Object-style</span>
<span class="co">CodeTree</span>::parse{|t| (t.x &gt; <span class="i">5</span>) &amp; (t.y &lt;= <span class="i">10</span>)     }  <span class="c"># =&gt; (&amp; (&gt; x, 5), (&lt;= z, 10))</span>

<span class="c"># Context-style</span>
<span class="co">CodeTree</span>::parse{ (x &gt; <span class="i">5</span>) &amp; (y &lt;= <span class="i">10</span>)            }  <span class="c"># =&gt; (&amp; (&gt; x, 5), (&lt;= z, 10))</span>

<span class="c"># Functional-style</span>
<span class="co">CodeTree</span>::parse{ (both (gt x, <span class="i">5</span>), (lte y, <span class="i">10</span>))  }  <span class="c"># =&gt; (both (gt x, 5), (lte z, 10))</span>
</pre></div>
</div>

<p>The parsing stage returns a code tree, which can be passed to a next stage (rewriting, evaluation, compilation or whatever).</p>
<h2>semantics</h2>
<p><strong>Branch nodes</strong> in the code tree correspond to a function call with arguments (see AstNode for details):</p>
<div class="CodeRay">
  <div class="code"><pre>(function arg0, arg1, arg2, ..., argn)</pre></div>
</div>

<p>where <code>arg0, arg1 ... argn</code> always are AstNode instances, expect for leaf nodes. Function name is accessible through the  <em>function</em> attribute (aliased as <em>name</em>). Arguments are accessible through the <em>arg</em> (aliased as <em>children</em>) attribute.</p>
<p><strong>Leaf nodes</strong> encode literals through the special <code>'\_'</code> function. The later takes only one argument, which can be any ruby object, and is accessible through the <em>literal</em> attribute. All and only leaf nodes have that function.</p>
<div class="CodeRay">
  <div class="code"><pre>(_ literal)</pre></div>
</div>

<p><strong>Variable references</strong> are denoted through a special function <code>'?'</code>. This operator expects one argument, i.e. the variable name, typically (but not necessarily) represented by a symbol literal.</p>
<div class="CodeRay">
  <div class="code"><pre>(? variable_name)</pre></div>
</div>

<h2>examples</h2>
<div class="CodeRay">
  <div class="code"><pre>
<span class="co">CodeTree</span>::parse{ <span class="i">12</span> }.inspect       <span class="c"># (_ 12)</span>
<span class="co">CodeTree</span>::parse{ <span class="sy">:x</span> }.inspect       <span class="c"># (_ :x)</span>
<span class="co">CodeTree</span>::parse{ x  }.inspect       <span class="c"># (? (_ :x))</span>
</pre></div>
</div>

<p>&#8216;_&#8217; and &#8216;?&#8217; operators only appear when invoking inspect:</p>
<div class="CodeRay">
  <div class="code"><pre>
<span class="co">CodeTree</span>::parse{ x + <span class="i">12</span> }.inspect   <span class="c"># (+ (? (_ :x)), (_ 12))</span>
<span class="co">CodeTree</span>::parse{ x + <span class="i">12</span> }.to_s      <span class="c"># (+ x, 12)</span>
</pre></div>
</div>

<h2>limitations</h2>
<p><strong>No imperative code</strong>: SByC implicitly assumes that block&#8217;s code can be interpreted functionally: no concept of variable, no sequence of code, no if/then/else, no loop. Said otherwise: your block code should always &#8220;compute a value&#8221;, without having any other (state) side effect. The following will <span class="caps">NOT</span> work:</p>
<div class="CodeRay">
  <div class="code"><pre>
<span class="co">CodeTree</span>::parse{ <span class="r">if</span> x <span class="r">then</span> <span class="i">0</span> <span class="r">else</span> <span class="i">1</span> <span class="r">end</span> }  <span class="c"># 0</span>
</pre></div>
</div>

<p><b>Evaluation at parsing time</b>: SByC does not uses ruby2ruby or similar libraries to get an <span class="caps">AST</span>. It simply executes the block inside a specific <span class="caps">DSL</span>. Therefore, ruby expressions on literals will be evaluated at parsing time, according to operator precedence and ordering:</p>
<div class="CodeRay">
  <div class="code"><pre>
<span class="co">CodeTree</span>::parse{ x + <span class="i">12</span> + <span class="i">17</span>     }      <span class="c"># =&gt; (+ (+ x, 12), 17)</span>
<span class="co">CodeTree</span>::parse{ x + (<span class="i">12</span> + <span class="i">17</span>)   }      <span class="c"># =&gt; (+ x, 29)</span>
<span class="co">CodeTree</span>::parse{ (x + <span class="i">12</span>) + <span class="i">17</span>   }      <span class="c"># =&gt; (+ (+ x, 12), 17)</span>
</pre></div>
</div>

<p><b>Ruby operator limitations</b>: for the same reason, only operators that rely on overridable methods are recognized. In particular, the following expressions will <span class="caps">NOT</span> work:</p>
<div class="CodeRay">
  <div class="code"><pre>
<span class="co">CodeTree</span>::parse{ x <span class="r">and</span> y }              <span class="c"># =&gt; y</span>
<span class="co">CodeTree</span>::parse{ x &amp;&amp; y  }              <span class="c"># =&gt; y</span>
<span class="co">CodeTree</span>::parse{ x <span class="r">or</span> y  }              <span class="c"># =&gt; x</span>
<span class="co">CodeTree</span>::parse{ x || y  }              <span class="c"># =&gt; x</span>
<span class="co">CodeTree</span>::parse{ <span class="r">not</span>(x)  }              <span class="c"># =&gt; false ... but works with Ruby &gt;= 1.9</span>
<span class="co">CodeTree</span>::parse{ !x      }              <span class="c"># =&gt; false ... but works with Ruby &gt;= 1.9</span>
</pre></div>
</div>

<h2>credits</h2>
<p>SByC &#8211; CodeTree &#169; 2010 by Bernard Lambeau. SByC is distributed under the <span class="caps">MIT</span> licence. Please see the <span class="caps">LICENCE</span>.md document for details.</p>
      </div>
  	</div>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-16520635-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
	</body>
</html>